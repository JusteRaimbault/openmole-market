//Parameters to tune for the Simulated Annealing
val T0 = Val[Double]          //Initiale temperature
val cexp = Val[Double]        //Coefficient for exponential decrease of temperature
val pas = Val[Double]         //Size of a step along x and y dimensions
val niter = Val[Double]       //Number of iteration of the algorithm

val a = Val[Double]
val b = Val[Double]
val c = Val[Double]

val discrete_a = Val[Int]
val discrete_b = Val[Int]
val discrete_c = Val[Int]

val strValue = Val[String]
val doubleValue = Val[Double]

val mapper = ScalaTask("""
                        |val borne_sup_a = 40.0
                        |val borne_sup_b = 2.0
                        |val borne_sup_c = 6.28
                        |val step_a = 5.0
                        |val step_b = 5.0
                        |val step_c = 5.0
                        |val a = discrete_a.toDouble*borne_sup_a/step_a.toDouble
                        |val b = discrete_b.toDouble*borne_sup_b/step_b.toDouble
                        |val c = discrete_c.toDouble*borne_sup_c/step_c.toDouble
                        """) set (
  inputs += (T0, cexp, pas, niter, discrete_a, discrete_b, discrete_c),
  outputs += (T0, cexp, pas, niter, a, b, c),
)

val AckleyFunction =
  CARETask( workDirectory / "Ackley_SA_niche.tgz.bin", "python Ackley_SA_niche.py ${T0} ${cexp} ${pas} ${niter} ${a} ${b} ${c}") set (
    inputs += (T0, cexp, pas, niter, a, b, c),      //These inputs are the same as the inputs of the python script
    outputs += (niter, strValue),                   //Only strValue is mandatory as output, the others are for debug
    
    stdOut := strValue,                             //Here we catch the python output as a string
    
    T0 := 0.1,                                      //Here are 4 defaults ouptuts for Debug
    cexp := 0.8,                                    //Defaults value allox you to run -> AckleyFunction hook ToStringHook()
    pas := 5.0,
    niter := 1000.0,
    a := 5.0,     //0, 40
    b := 1.0,     //0, 2
    c := 0.1     //0, 2pi
)

val toDouble = ScalaTask("val doubleValue = strValue.toDouble") set (
  inputs += strValue,
  outputs += doubleValue
)

//version continue
val nnsga = NichedNSGA2(
  nicheSize = 20,  //Size of the population
  genome = Seq(T0 in (0.0, 3.0),
               cexp in (0.5, 1.0),
               pas in (0.1, 5.0),
               niter in (100.0, 10000.0),
               discrete_a in (0 to 5),
               discrete_b in (0 to 5),
               discrete_c in (0 to 5)
               ), //Space in which the population is sampled, values are rough estimations
  niche = Seq(discrete_a, discrete_b, discrete_c),
  objectives = Seq(doubleValue)  //We want to optimize over three parameters
)

val evolution = SteadyStateEvolution(
  algorithm = nnsga,
  evaluation = mapper -- AckleyFunction -- toDouble,
  parallelism = 10,
  termination = 2000
)
 
val savePopulation = SavePopulationHook(evolution, workDirectory / "evolution_niche1/")

(evolution hook savePopulation on LocalEnvironment(4))
